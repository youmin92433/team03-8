<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <label><input type="checkbox" id="check-all"> 전체 선택</label>
    <hr>
    <!-- 개별 항목들을 감싸는 컨테이너 추가! -->
    <div id="item-container">
        <label><input type="checkbox" class="item" value="사과"> 사과</label>
        <label><input type="checkbox" class="item" value="바나나"> 바나나</label>
        <label><input type="checkbox" class="item" value="오렌지"> 오렌지</label>
        <label><input type="checkbox" class="item" value="포도"> 포도</label>
    </div>
    <p id="selected">선택된 항목: </p>
</body>
<script>
    // ===== 1. 요소 선택 =====
    
    // 전체 선택 체크박스
    const checkAll = document.getElementById("check-all");
    
    // 개별 체크박스들의 "부모" 컨테이너
    // → 이벤트 위임의 핵심! 자식들 대신 부모가 이벤트를 받음
    const container = document.getElementById("item-container");
    
    // 결과 표시 p태그
    const p = document.getElementById("selected");

    // ===== 2. 개별 항목 가져오는 함수 =====
    
    // 왜 함수로 만들었나?
    // → 나중에 체크박스가 동적으로 추가/삭제될 수 있음
    // → 그때마다 새로 조회해야 정확한 목록을 얻음
    function getItems() {
        return container.querySelectorAll("input.item");
    }

    // ===== 3. 선택된 항목 표시 함수 =====
    
    function updateSelected() {
        // 현재 존재하는 개별 체크박스들을 가져옴
        const items = getItems();
        
        let result = "선택된 항목: ";
        
        // 각 체크박스를 확인해서 체크된 것의 value를 추가
        items.forEach((item) => {
            if(item.checked) {
                result += item.value + " ";
            }
        });
        
        p.textContent = result;
    }

    // ===== 4. 전체 선택 이벤트 =====
    
    checkAll.addEventListener("change", (e) => {
        // 현재 존재하는 모든 개별 체크박스를 가져와서
        // 전체 선택과 같은 상태로 만듦
        getItems().forEach((item) => {
            item.checked = checkAll.checked;
        });
        
        updateSelected();
    });

    // ===== 5. 이벤트 위임 - 핵심! =====
    
    // 기존 방식의 문제점:
    // items.forEach((item) => {
    //     item.addEventListener("change", ...);
    // });
    // → 페이지 로드 시점에 존재하는 체크박스에만 이벤트가 붙음
    // → 나중에 JavaScript로 새 체크박스를 추가하면 이벤트가 없음!
    
    // 이벤트 위임 방식:
    // → 부모(container)에게 이벤트를 등록
    // → 자식에서 발생한 이벤트가 부모로 "버블링"됨
    // → 부모가 대신 처리!
    
    container.addEventListener("change", (e) => {
        
        // e.target: 실제로 이벤트가 발생한 요소
        // → container가 아니라, 클릭된 체크박스!
        
        // classList.contains("item"): 해당 요소가 "item" 클래스를 가지고 있는지
        // → 우리가 원하는 체크박스인지 확인
        // → 다른 요소에서 이벤트가 발생했을 수도 있으니까
        
        if(e.target.classList.contains("item")) {
            
            // 현재 존재하는 모든 개별 체크박스 가져옴
            const items = getItems();
            
            // 모두 체크됐는지 확인
            const allChecked = Array.from(items).every((i) => i.checked);
            
            // 전체 선택 동기화
            checkAll.checked = allChecked;
            
            // 화면 업데이트
            updateSelected();
        }
    });
    
    // ===== 보너스: 동적으로 체크박스 추가해보기 =====
    
    // 3초 후에 새 체크박스 추가
    setTimeout(() => {
        // 새로운 label과 checkbox 생성
        const newLabel = document.createElement("label");
        newLabel.innerHTML = '<input type="checkbox" class="item" value="딸기"> 딸기';
        
        // 컨테이너에 추가
        container.appendChild(newLabel);
        
        console.log("딸기가 추가됐습니다! 클릭해보세요 - 이벤트가 동작합니다!");
    }, 3000);
</script>
</html>
```

---

## 이벤트 위임 시각화
```
[기존 방식]

페이지 로드 시:
사과□ ← 이벤트 등록!
바나나□ ← 이벤트 등록!
오렌지□ ← 이벤트 등록!
포도□ ← 이벤트 등록!

나중에 추가:
딸기□ ← 이벤트 없음! ❌ 클릭해도 반응 없음


[이벤트 위임 방식]

페이지 로드 시:
┌─────────────────────────┐
│  container ← 이벤트 등록! │
│  ┌─────────────────────┐ │
│  │ 사과□ 바나나□        │ │
│  │ 오렌지□ 포도□        │ │
│  └─────────────────────┘ │
└─────────────────────────┘

나중에 추가:
┌─────────────────────────┐
│  container ← 여전히 이벤트 있음! │
│  ┌─────────────────────┐ │
│  │ 사과□ 바나나□        │ │
│  │ 오렌지□ 포도□        │ │
│  │ 딸기□ ← 새로 추가!   │ │ ✓ 클릭하면 동작함!
│  └─────────────────────┘ │
└─────────────────────────┘

왜? 딸기를 클릭하면:
딸기 클릭 → 이벤트 버블링 → container가 받음 → 처리!